<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>行動学習スケジューラー</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  /* シンプルなタイムライン用スタイル */
  .timeline { position: relative; height: 160px; border: 1px solid rgba(255,255,255,0.06); background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding: 12px; border-radius: 10px; }
  .timeline-row { position: relative; height: 36px; margin-bottom: 8px; }
  .timeline-label { position: absolute; left: 0; top: 0; bottom: 0; width: 160px; display:flex;align-items:center;padding-left:8px;color:#cbd5e1;font-size:13px }
  .timeline-track { position: absolute; left: 170px; right: 12px; top: 0; bottom: 0; }
  .timeline-bar { position: absolute; height: 28px; top: 4px; border-radius: 6px; display:flex;align-items:center;padding-left:8px;color:#001; font-weight:600; }
</style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-6 font-sans">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-2xl font-bold mb-4">行動学習スケジューラー</h1>

    <!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>行動学習スケジューラー</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  .timeline { position: relative; height: 160px; border: 1px solid rgba(255,255,255,0.06); background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding: 12px; border-radius: 10px; }
  .timeline-row { position: relative; height: 36px; margin-bottom: 8px; }
  .timeline-label { position: absolute; left: 0; top: 0; bottom: 0; width: 160px; display:flex;align-items:center;padding-left:8px;color:#cbd5e1;font-size:13px }
  .timeline-track { position: absolute; left: 170px; right: 12px; top: 0; bottom: 0; }
  .timeline-bar { position: absolute; height: 28px; top: 4px; border-radius: 6px; display:flex;align-items:center;padding-left:8px;color:#001; font-weight:600; }
</style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-6 font-sans">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-2xl font-bold mb-4">行動学習スケジューラー</h1>

```
<div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
  <div class="bg-gray-800 p-4 rounded-lg">
    <h2 class="font-semibold mb-2">タスク追加</h2>
    <input id="title" class="w-full p-2 rounded mb-2 bg-gray-700" placeholder="タイトル" />
    <input id="deadline" type="datetime-local" class="w-full p-2 rounded mb-2 bg-gray-700" />
    <input id="genre" class="w-full p-2 rounded mb-2 bg-gray-700" placeholder="ジャンル" />
    <input id="subjective" type="number" class="w-full p-2 rounded mb-2 bg-gray-700" placeholder="主観的重要度(1-10)" />
    <input id="objective" type="number" class="w-full p-2 rounded mb-2 bg-gray-700" placeholder="客観的重要度(1-10)" />
    <input id="duration" type="number" class="w-full p-2 rounded mb-2 bg-gray-700" placeholder="見積時間(分)" />
    <button id="addTask" class="w-full bg-blue-600 hover:bg-blue-500 py-2 rounded font-semibold">追加</button>

    <!-- ✅ タスク一覧 -->
    <div class="bg-gray-800 p-4 rounded-lg mt-4">
      <h2 class="font-semibold mb-2">タスク一覧</h2>
      <div id="taskList" class="space-y-2"></div>
    </div>
  </div>

  <div class="col-span-2 bg-gray-800 p-4 rounded-lg">
    <h2 class="font-semibold mb-2">スケジュール生成</h2>
    <div class="flex gap-2 mb-3">
      <input id="date" type="date" class="p-2 rounded bg-gray-700" />
      <button id="generate" class="bg-green-600 hover:bg-green-500 py-2 px-4 rounded font-semibold">生成</button>
    </div>

    <div id="scheduleList" class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4"></div>

    <div>
      <h3 class="font-medium mb-2">タイムライン</h3>
      <div id="timeline" class="timeline"></div>
    </div>
  </div>
</div>

<div class="bg-gray-800 p-4 rounded-lg mt-4">
  <h2 class="font-semibold mb-2">フィードバック</h2>
  <div class="grid grid-cols-1 md:grid-cols-4 gap-2">
    <select id="feedbackTask" class="col-span-2 p-2 rounded bg-gray-700"></select>
    <input id="actualDuration" type="number" placeholder="実績時間(分)" class="p-2 rounded bg-gray-700" />
    <select id="completed" class="p-2 rounded bg-gray-700"><option value="1">完了した</option><option value="0">未完了</option></select>
  </div>
  <div class="mt-3">
    <button id="saveFeedback" class="bg-yellow-500 hover:bg-yellow-400 py-2 px-4 rounded font-semibold">フィードバックを保存</button>
  </div>
</div>
```

  </div>

<script>
const STORAGE_KEY = 'behavior_scheduler_db_v2';
let db = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{"tasks":[],"records":[]}');

const titleEl = document.getElementById('title');
const deadlineEl = document.getElementById('deadline');
const genreEl = document.getElementById('genre');
const subjectiveEl = document.getElementById('subjective');
const objectiveEl = document.getElementById('objective');
const durationEl = document.getElementById('duration');
const addBtn = document.getElementById('addTask');
const generateBtn = document.getElementById('generate');
const scheduleList = document.getElementById('scheduleList');
const timelineRoot = document.getElementById('timeline');
const feedbackTaskEl = document.getElementById('feedbackTask');
const actualDurationEl = document.getElementById('actualDuration');
const completedEl = document.getElementById('completed');
const saveFeedbackBtn = document.getElementById('saveFeedback');
const taskListEl = document.getElementById('taskList');

function saveDB(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(db)); }

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }

function renderTasksInFeedback(){
  while(feedbackTaskEl.firstChild) feedbackTaskEl.removeChild(feedbackTaskEl.firstChild);
  if(!db.tasks || db.tasks.length===0){
    const opt = document.createElement('option'); opt.value=''; opt.textContent='（タスクなし）'; feedbackTaskEl.appendChild(opt); return;
  }
  db.tasks.forEach((t,i)=>{
    const opt = document.createElement('option'); opt.value = String(i); opt.textContent = t.title; feedbackTaskEl.appendChild(opt);
  });
}

// ✅ タスク一覧表示関数
function renderTaskList(){
  while(taskListEl.firstChild) taskListEl.removeChild(taskListEl.firstChild);
  if(!db.tasks || db.tasks.length===0){
    const msg = document.createElement('div');
    msg.textContent = 'タスクがありません';
    msg.className = 'text-gray-400 text-sm';
    taskListEl.appendChild(msg);
    return;
  }

  db.tasks.forEach((t, i)=>{
    const card = document.createElement('div');
    card.className = 'p-3 bg-gray-700 rounded flex justify-between items-center';

    const info = document.createElement('div');
    info.innerHTML = `<div class="font-semibold">${escapeHtml(t.title)}</div>
                      <div class="text-sm text-gray-300">期限: ${escapeHtml(t.deadline||'未設定')} / ジャンル: ${escapeHtml(t.genre||'未設定')}</div>`;
    card.appendChild(info);

    const delBtn = document.createElement('button');
    delBtn.textContent = '削除';
    delBtn.className = 'bg-red-600 hover:bg-red-500 px-3 py-1 rounded text-sm font-semibold';
    delBtn.addEventListener('click', ()=>{
      if(confirm(`「${t.title}」を削除しますか？`)){
        db.tasks.splice(i,1);
        saveDB();
        renderTaskList();
        renderTasksInFeedback();
      }
    });
    card.appendChild(delBtn);
    taskListEl.appendChild(card);
  });
}

// タスク追加
addBtn.addEventListener('click', ()=>{
  const t = {
    title: (titleEl.value || '').trim(),
    deadline: deadlineEl.value || '',
    genre: (genreEl.value || '').trim() || '未設定',
    subjective: Number(subjectiveEl.value) || 5,
    objective: Number(objectiveEl.value) || 5,
    duration: Number(durationEl.value) || 30
  };
  if(!t.title) { alert('タイトルを入力してください'); return; }
  db.tasks.push(t);
  db.records.push({task: t, completed: 0, actualDuration: null});
  saveDB();
  titleEl.value=''; deadlineEl.value=''; genreEl.value=''; subjectiveEl.value=''; objectiveEl.value=''; durationEl.value='';
  renderTaskList();
  renderTasksInFeedback();
});

// featurize
function featurize(task){
  return [ (task.subjective||0)/10, (task.objective||0)/10, Math.log(1+(task.duration||30))/Math.log(1+240) ];
}

let model = null;
async function trainModel(records){
  if(!records || records.length===0) return;
  const data = records.filter(r=>r && r.task).slice(-500);
  if(data.length===0) return;
  const xs = tf.tensor2d(data.map(d=>featurize(d.task)));
  const ys = tf.tensor2d(data.map(d=>[d.completed?1:0]));
  model = tf.sequential();
  model.add(tf.layers.dense({inputShape:[3], units:8, activation:'relu'}));
  model.add(tf.layers.dense({units:4, activation:'relu'}));
  model.add(tf.layers.dense({units:1, activation:'sigmoid'}));
  model.compile({optimizer:'adam', loss:'binaryCrossentropy'});
  await model.fit(xs, ys, {epochs:20, batchSize:Math.min(16, data.length)});
  xs.dispose(); ys.dispose();
}

// スケジュール生成
generateBtn.addEventListener('click', async ()=>{
  if(!db.tasks || db.tasks.length===0){ alert('タスクを追加してください'); return; }
  if(!model && db.records && db.records.length>0) await trainModel(db.records);

  const scored = await Promise.all(db.tasks.map(async t=>{
    if(model){
      const v = tf.tensor2d([featurize(t)]);
      const p = (await model.predict(v).data())[0]; v.dispose(); return {...t, score: p};
    } else {
      return {...t, score: Math.random()*0.5 + 0.25};
    }
  }));
  scored.sort((a,b)=>b.score - a.score);

  while(scheduleList.firstChild) scheduleList.removeChild(scheduleList.firstChild);
  scored.forEach(s=>{
    const card = document.createElement('div'); card.className='p-3 bg-gradient-to-r from-gray-700 to-gray-600 rounded-xl shadow-md';
    const h = document.createElement('div'); h.className='font-semibold'; h.textContent = s.title; card.appendChild(h);
    const meta = document.createElement('div'); meta.className='text-sm text-gray-300'; meta.textContent = `ジャンル: ${s.genre || '未設定'} | 期限: ${s.deadline || '未設定'}`; card.appendChild(meta);
    const score = document.createElement('div'); score.className='text-sm mt-1 text-blue-300 font-bold'; score.textContent = `優先度: ${(s.score*100).toFixed(1)}%`; card.appendChild(score);
    scheduleList.appendChild(card);
  });

  renderTimeline(scored);
  scored.forEach(s => db.records.push({task: s, completed: 0, actualDuration: null}));
  saveDB();
  renderTaskList();
  renderTasksInFeedback();
});

function renderTimeline(tasks){
  while(timelineRoot.firstChild) timelineRoot.removeChild(timelineRoot.firstChild);
  if(!tasks || tasks.length===0) return;
  const total = tasks.reduce((sum,t)=> sum + (t.duration||30), 0) || 1;
  let cur = 0;
  tasks.forEach(t => {
    const row = document.createElement('div'); row.className='timeline-row';
    const label = document.createElement('div'); label.className='timeline-label'; label.textContent = t.title;
    const track = document.createElement('div'); track.className='timeline-track';
    const bar = document.createElement('div'); bar.className='timeline-bar';
    const leftPercent = (cur/total) * 100;
    const widthPercent = ((t.duration||30)/total) * 100;
    bar.style.left = leftPercent + '%';
    bar.style.width = Math.max(2, widthPercent) + '%';
    const hue = Math.round(200 - (t.score||0)*120);
    bar.style.background = `hsl(${hue} 90% 65%)`;
    bar.textContent = `${t.duration||30}m`;
    track.appendChild(bar);
    row.appendChild(label); row.appendChild(track);
    timelineRoot.appendChild(row);
    cur += (t.duration||30);
  });
}

// フィードバック保存
saveFeedbackBtn.addEventListener('click', async ()=>{
  const idx = Number(feedbackTaskEl.value);
  if(isNaN(idx) || !db.tasks[idx]){ alert('対象タスクを選択してください'); return; }
  const dur = Number(actualDurationEl.value) || db.tasks[idx].duration || 0;
  const comp = Number(completedEl.value) || 0;
  db.records.push({task: db.tasks[idx], completed: comp, actualDuration: dur});
  saveDB();
  alert('フィードバックを保存しました');
  await trainModel(db.records);
  renderTaskList();
  renderTasksInFeedback();
});

renderTaskList();
renderTasksInFeedback();
</script>

</body>
</html>

  </div>

<script>
// --- 軽量で堅牢な実装に差し替え（テンプレートリテラルによるバランス問題を避ける）
const STORAGE_KEY = 'behavior_scheduler_db_v2';
let db = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{"tasks":[],"records":[]}');

// DOM
const titleEl = document.getElementById('title');
const deadlineEl = document.getElementById('deadline');
const genreEl = document.getElementById('genre');
const subjectiveEl = document.getElementById('subjective');
const objectiveEl = document.getElementById('objective');
const durationEl = document.getElementById('duration');
const addBtn = document.getElementById('addTask');
const generateBtn = document.getElementById('generate');
const scheduleList = document.getElementById('scheduleList');
const timelineRoot = document.getElementById('timeline');
const feedbackTaskEl = document.getElementById('feedbackTask');
const actualDurationEl = document.getElementById('actualDuration');
const completedEl = document.getElementById('completed');
const saveFeedbackBtn = document.getElementById('saveFeedback');

function saveDB(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(db)); }

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]); }

function renderTasksInFeedback(){
  while(feedbackTaskEl.firstChild) feedbackTaskEl.removeChild(feedbackTaskEl.firstChild);
  if(!db.tasks || db.tasks.length===0){
    const opt = document.createElement('option'); opt.value=''; opt.textContent='（タスクなし）'; feedbackTaskEl.appendChild(opt); return;
  }
  db.tasks.forEach((t,i)=>{
    const opt = document.createElement('option'); opt.value = String(i); opt.textContent = t.title; feedbackTaskEl.appendChild(opt);
  });
}

// add task
addBtn.addEventListener('click', ()=>{
  const t = {
    title: (titleEl.value || '').trim(),
    deadline: deadlineEl.value || '',
    genre: (genreEl.value || '').trim() || '未設定',
    subjective: Number(subjectiveEl.value) || 5,
    objective: Number(objectiveEl.value) || 5,
    duration: Number(durationEl.value) || 30
  };
  if(!t.title) { alert('タイトルを入力してください'); return; }
  db.tasks.push(t);
  db.records.push({task: t, completed: 0, actualDuration: null});
  saveDB();
  // clear
  titleEl.value=''; deadlineEl.value=''; genreEl.value=''; subjectiveEl.value=''; objectiveEl.value=''; durationEl.value='';
  renderTasksInFeedback();
});

// featurize
function featurize(task){
  return [ (task.subjective||0)/10, (task.objective||0)/10, Math.log(1+(task.duration||30))/Math.log(1+240) ];
}

let model = null;
async function trainModel(records){
  if(!records || records.length===0) return;
  const data = records.filter(r=>r && r.task).slice(-500);
  if(data.length===0) return;
  // build tensors
  const xs = tf.tensor2d(data.map(d=>featurize(d.task)));
  const ys = tf.tensor2d(data.map(d=>[d.completed?1:0]));
  model = tf.sequential();
  model.add(tf.layers.dense({inputShape:[3], units:8, activation:'relu'}));
  model.add(tf.layers.dense({units:4, activation:'relu'}));
  model.add(tf.layers.dense({units:1, activation:'sigmoid'}));
  model.compile({optimizer:'adam', loss:'binaryCrossentropy'});
  await model.fit(xs, ys, {epochs:20, batchSize:Math.min(16, data.length)});
  xs.dispose(); ys.dispose();
}

// generate schedule (no Chart.js, DOM + CSS timeline)
generateBtn.addEventListener('click', async ()=>{
  if(!db.tasks || db.tasks.length===0){ alert('タスクを追加してください'); return; }
  if(!model && db.records && db.records.length>0) await trainModel(db.records);

  // score
  const scored = await Promise.all(db.tasks.map(async t=>{
    if(model){
      const v = tf.tensor2d([featurize(t)]);
      const p = (await model.predict(v).data())[0]; v.dispose(); return Object.assign({}, t, {score: p});
    } else {
      return Object.assign({}, t, {score: Math.random()*0.5 + 0.25});
    }
  }));
  scored.sort((a,b)=>b.score - a.score);

  // render list
  while(scheduleList.firstChild) scheduleList.removeChild(scheduleList.firstChild);
  scored.forEach(s=>{
    const card = document.createElement('div'); card.className='p-3 bg-gradient-to-r from-gray-700 to-gray-600 rounded-xl shadow-md';
    const h = document.createElement('div'); h.className='font-semibold'; h.textContent = s.title; card.appendChild(h);
    const meta = document.createElement('div'); meta.className='text-sm text-gray-300'; meta.textContent = `ジャンル: ${s.genre || '未設定'} | 期限: ${s.deadline || '未設定'}`; card.appendChild(meta);
    const score = document.createElement('div'); score.className='text-sm mt-1 text-blue-300 font-bold'; score.textContent = `優先度: ${(s.score*100).toFixed(1)}%`; card.appendChild(score);
    scheduleList.appendChild(card);
  });

  // timeline
  renderTimeline(scored);

  // add planned records for feedback
  scored.forEach(s => db.records.push({task: s, completed: 0, actualDuration: null}));
  saveDB();
  renderTasksInFeedback();
});

function renderTimeline(tasks){
  // clear
  while(timelineRoot.firstChild) timelineRoot.removeChild(timelineRoot.firstChild);
  if(!tasks || tasks.length===0) return;
  const total = tasks.reduce((sum,t)=> sum + (t.duration||30), 0) || 1;
  let cur = 0;
  tasks.forEach(t => {
    const row = document.createElement('div'); row.className='timeline-row';
    const label = document.createElement('div'); label.className='timeline-label'; label.textContent = t.title;
    const track = document.createElement('div'); track.className='timeline-track';
    const bar = document.createElement('div'); bar.className='timeline-bar';
    const leftPercent = (cur/total) * 100;
    const widthPercent = ((t.duration||30)/total) * 100;
    bar.style.left = leftPercent + '%';
    bar.style.width = Math.max(2, widthPercent) + '%';
    // color based on score
    const hue = Math.round(200 - (t.score||0)*120); // 80..200
    bar.style.background = `hsl(${hue} 90% 65%)`;
    bar.textContent = `${t.duration||30}m`;
    track.appendChild(bar);
    row.appendChild(label); row.appendChild(track);
    timelineRoot.appendChild(row);
    cur += (t.duration||30);
  });
}

// feedback
saveFeedbackBtn.addEventListener('click', async ()=>{
  const idx = Number(feedbackTaskEl.value);
  if(isNaN(idx) || !db.tasks[idx]){ alert('対象タスクを選択してください'); return; }
  const dur = Number(actualDurationEl.value) || db.tasks[idx].duration || 0;
  const comp = Number(completedEl.value) ? 1 : 0;
  db.records.push({task: db.tasks[idx], actualDuration: dur, completed: comp});
  saveDB();
  await trainModel(db.records);
  alert('フィードバックを保存し、モデルを更新しました');
  renderTasksInFeedback();
});

// init
renderTasksInFeedback();
</script>
</body>
</html>
